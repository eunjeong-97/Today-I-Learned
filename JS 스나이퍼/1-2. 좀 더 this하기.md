# this

## this가 존재하는 이유

아래의 상황일 때 사용이 불편하기 때문이다
- menu 함수는 myDinner 변수의 이름이 수정되거나
- menu 함수 자체를 다른 객체에서 사용하고 싶은 경우
- ** 재사용하기 어렵다**
  
```javascript
var myDinner = {
  name: '김치찌개',
  menu: function() {
    console.log('오늘 저녁은 ' + myDinner.name);
  }
}

myDinner.menu();
```

```javascript
function menuGlobal() {
  console.log('오늘 저녁은' + this.name);
}

var myDinner = {
  name: '김치찌개',
  menu: menuGlobal
}

var yourDinner = {
  name: '된장찌개',
  menu: menuGlobal
}
```

## this의 제어

일반적으로 this의 값은 자동으로 할당되지만, 상황에 따라 제어할 수 있어야 한다


### 1. call() 메서드

this의 값을 바꿀 수도 있고, 함수를 실행할 때 사용할 인수도 전달할 수 있다.

- 1st 인자: this가 바라볼 객체
- 2st 인자: 매개변수

```javascript
function menuGlobal(item) {
  console.log('오늘 저녁은' + item + this.name);
}

var myDinner = {
  name: '김치찌개'
}

var yourDinner = {
  name: '된장찌개'
}

menuGlobal.call(myDinner, '묵은지');
menuGlobal.call(yourDinner, '삼겹살');
```

### 2. apply() 메서드

함수를 실행할 때 인수를 배열로 묶어 한 번에 전달한다
forEach 안에서 this를 전달받으려면 두 번째 인자로 this를 선언해줘야 한다
만약 this를 별도로 선언해주지 않는다면, forEach() 메서드를 실행하는 객체 `window, 전역객체` 를 바라보게 된다 : 상위스코프를 바라보게 된다

```javascript
function menuGlobal(item1, item2) {
  [item1, item2].forEach(function(el) {
    console.log('오늘 저녁은 ' + el + this.name )
  }, this);

menuGlobal.apply(myDinner, ['묵은지', '삼겹살']);
/* 실행 결과
오늘 저녁은 묵은지김치찌개
오늘 저녁은 삼겹살김치찌개
*/
}
```

### call와 apply의 차이

인수를 배열로 보낸다는 점을 제외하면, call과 apply는 동일한 기능을 수행한다

- call : 함수를 실행할 때 전달한 인수를 하나씩 전달한다
- apply : 전달할 인수를 배열로 묶어 한 번에 전달하기 때문에 인수를 두개만 사용한다

### 3. bind() 메서드

- ES5에서 추가된 개념로, this 값을 어디서 사용하던 호출 객체가 바뀌지 않게 고정시켜준다
- 인자로 this 값으로 고정할 객체를 넣어준다

```javascript
function menuGlobal(item) {
  console.log('오늘 저녁은 ' + item + this.name);
}

var menuGlobalForMe = menuGlobal.bind(myDinner);
var menuGlobalForYou = menuGlobal.bind(yourDinner);

console.log(menuGlobalForMe('묵은지')); 
/* 실행결과
오늘 저녁은 묵은지김치찌개
undefined | menuGlobal함수가 별도로 return 하는 값이 없기 때문에 생김
this = myDinner
*/

console.log(menuGlobalForYou('삼겹살'));
/* 실행결과
오늘 저녁은 삼겹살김치찌개
undefined
this = yourDinner
*/
```

menuGlobalForMe 변수에는 바라보는 객체가 myDinner로 고정된 menuGlobal함수가 할당된다

만약 myDinner에 새로운 key값을 할당하고 인자를 전달하면
아래와 같은 결과를 확인할 수 있다

```javascript
myDinner.menuMine = menuGlobalForYou;
myDinner.menuMine('묵은지'); // 오늘 저녁은 묵은지된장찌개

// 자바스크립트에서 처리하는 내용
var myDinner = {
  name: '김치찌개',
  mwnuMine: menuGlobalForYou
}
```

다른 객체에서 실행하는 함수도 그 함수가 바라보는 객체를 고정시킬 수 있다

## 화살표 함수와 this

일반적인 this처럼 함수를 호출한 객체를 할당하지 않고, 바로 상위 스코프의 this를 할당한다

```javascript
function menuGlobal(item1, item2) {
  console.log(this); // { name: '김치찌개' }
  [item1, item2].forEach((el) => {
    console.log('오늘 저녁은 ' + el + this.name)
  });
}

var myDinner = {
  name: '김치찌개'
}

var yourDinner = {
  name: '된장찌개'
}

menuGlobal.apply(myDinner, ['묵은지', '삼겹살']);

/* 실행결과
'오늘 저녁은 묵은지김치찌개'
'오늘 저녁은 삼겹살김치찌개'
*/
```

forEach의 상위 스코프인 myDinner를 바라보게 된다

> #### forEach문 안의 this

원래는 window 전역 스코프를 바라보는 것이 맞지만,
화살표함수를 사용하게 되면 상위 스코프를 바라보게 된다