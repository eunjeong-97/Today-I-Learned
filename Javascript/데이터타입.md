# 목차

1. [데이터 타입](#데이터-타입)
2. [식별자와 변수](#식별자와-변수)
3. [불변값과 가변값](#불변값과-가변값)
4. [참조형 데이터](#참조형-데이터)
5. [기본형 데이터와 참조형 데이터 비교](#기본형-데이터와-참조형-데이터-비교)
6. [불변객체](#불변-객체)
7. [얕은 복사와 깊은 복사](#얕은-복사와-깊은-복사) [✅](https://velog.io/@beanlove97/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%96%95%EC%9D%80%EB%B3%B5%EC%82%AC-%EA%B9%8A%EC%9D%80%EB%B3%B5%EC%82%AC)
8. [undefined와 null](#undefined와-null)
9. [정리](#정리)

> 출처 : 코어자바스크립트 챕터1 데이터 타입

> 공부날짜: 2021-11-09

# 데이터 타입

기본형 타입과 참조형 타입이 서로 다르게 동작하는 이유
데이터 타입과 관련된 중요한 개념 몇 가지

## 데이터 타입의 종류

### 기본형 (원시형)

> primitive type

숫자, 문자열, 불리언, null, undefined
ES6추가 : 심볼(Symbol)

### 참조형 

> reference type

객체, 배열, 함수, 날짜, 정규표현식
ES6추가 : Map, WeakMap, Set, WeakSet

![](https://images.velog.io/images/beanlove97/post/cc5276df-7d12-47b2-a4d6-fe0c5db4c45f/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-11-09%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2011.00.58.png)

### 구분 기준

> 기본형

- 할당이나 연산할 때 복제된다
- 값이 담긴 주솟값을 바로 복제한다
- 불변성 `immutabillty` 을 띈다

> 참조형

- 할당이나 연산할 때 참조한다
- 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제한다

## 메모리와 데이터

> 비트

0또는 1만 표현할 수 있는 하나의 메모리 조각
메모리는 매우 많은 비트로 구성되어 있는데, 각 비트는 고유한 식별자 `unique identifier` 를 통해 위치를 확인할 수 있다
0이나 1만 표현이 가능한 비트 단위로 위치를 확인하는 것은 배우 비효율적이기 때문에
몇 개씩 묶어 하나의 단위로 여겨서 표현할 수 있는 값도 늘어나고 동시에 검색 시간을 줄인다

> 바이트 

매우 많은 비트를 한 단위로 묶으면, 검색 시간은 줄이고 표현할 수 있는 데이터의 개수도 늘어나겠지만 동시에 낭비되는 비트도 생긴다
자주 사용하지 않을 데이터를 표현하기 위해 ~~빈 공간을 남겨놓기보다는~~ 표현 가능한 개수에 어느 정도 제약이 따르더라도 크게 문제가 되지 않을 적정한 공간을 묶는 것이 낫다
이렇게 바이트라는 단위가 생겼다

> C/C++, 자바 등의 정적 타입 언어

메모리의 낭비를 최소화하기 위해 데이터 타입별로 할당할 메모리 영역을 2바이트, 4바이트 등으로 나누어 정했다

2바이트 크기의 정수형 타입 `short` : 0을 포함해 -32768 ~ +32767 숫자만 허용한다
만약 사용자가 32767보다 더 큰 숫자를 입력하게 되면 오류가 나거나 잘못된 값이 저장된다

이러한 문제에 대처하기 위해 번거롭긴 하지만 사용자가 직접 4바이트 크기의 정수형타입 `int` 등으로 형변환해야 한다

> 자바스크립트

메모리 용량이 과거보다 월등히 커진 상황에서 등장한 자바스크립트는 상대적으로 메모리 관리에 대한 압박에서 자유로웠다.
그래서 메모리 공간을 좀 더 넉넉하게 할당했기 때문에 개발자가 형변환을 걱정해야 하는 상황이 덜 발생했다

```
숫자 : 정수형인지 부동소수형인지 구분하지 않고 64비트 (=8바이트) 확보
```

각 비트는 고유한 식별자를 가지기 때문에 바이트 역시 시작하는 비트의 식별자로 위치를 파악할 수 있다
모든 데이터는 바이트 단위의 식별자, 더 정확하게는 메모리 주솟값 `memory address` 을 통해 서로 구분하고 연결할 수 있다

[목차로 이동](#목차)

# 식별자와 변수

불변성을 이해하기 위해서는 메모리와 데이터에 대한 지식이 필요하고, '식별자'와 '변수'의 개념을 구분해야 한다

보통 변수 `variable` 와 식별자 `identifier` 를 혼용하는 경우가 많은데
혼용이 가능한 이유는 대부분의 경우, 문맥에 따라 무엇을 말하고자 하는지를 유추할 수 있기 때문이다

> 변수

변할 수 있는 무언가 (데이터) 
이름 자체를 보면, 변할 수 있는 수 (반드시 숫자여야 하지 않는다) 이긴 하지만
데이터에는 숫자, 문자열, 객체, 배열 모두 포함한다

> 식별자

어떤 데이터를 식별하는 데 사용하는 이름
변수명

## 변수 선언과 데이터 할당

```javascript
var a
```

변할 수 있는 데이터를 만든다
이 데이터의 식별자는 a로 한다

변할 수 있는 데이터이기 때문에 선언할 때는 undefined이더라도 나중에 다른 값으로 바꾸면 된다
변수 : 변경 가능한 데이터가 담길 수 있는 공간 (그릇)

### 변수 선언 과정

자바스크립트의 데이터 구조 이해라는 목적에 필요한 만큼만 컴퓨터가 명령을 받아 메모리 영역에서 어떤 작업을 수행하는지 표현한다면

명령을 받은 컴퓨터는 메모리에서 비어있는 공간 하나를 확보한다
여기서는 임의로 1003번으로 정했다.
이 공간의 이름(식별자)를 a라고 지정한다

![](https://images.velog.io/images/beanlove97/post/5f5ea5f0-cda7-422b-b71e-109a1dd03175/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-11-09%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2011.23.40.png)

이후에 사용자가 a에 접근하고자 하면 : 컴퓨터는 메모리에서 a라는 이름을 가진 주소를 검색해 -> 해당 공간에 담긴 데이터를 반환한다

### 데이터 할당

```javascript
var a; // 변수 a 선언
a = 'abc'; // 변수 a에 데이터 할당

var a = 'abc'; // 변수 선언과 할당을 한 문장으로 표현
```

선언과 할당을 두 문장으로 나누어 명령을 하던, 한 문장으로 명령하던, 자바스크립트 엔진은 결국 같은 동작을 수행한다.

a라는 이름을 가진 주소를 검색해서 그곳에 문자열 'abc'를 할당하면 될 것 같지만
실제로는 해당 위치에 문자열 'abc' 를 직접 저장하지 않는다.
데이터를 저장하기 위한 별도의 메모리 공간을 다시 확보해서 문자열 'abc'를 저장하고, 
그 주소를 변수 영역에 저장하는 식으로 이루어진다

![](https://images.velog.io/images/beanlove97/post/49a9fca2-ff7b-4671-aa67-70fc81a99ad5/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-11-09%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2011.29.42.png)

1. 변수 영역에서 빈공간 `@1003` 을 확보한다
2. 확보한 공간의 식별자를 a로 지정한다
3. 데이터 영역의 빈 공간 `@5004` 에 문자열 'abc'를 저장한다
4. 변수 영역에서 a라는 식별자를 검색한다 `@1003`
5. 앞서 저장한 문자열의 주소 `@5004` 를 `@1003` 의 공간에 대입한다 

> 변수 영역에 값을 직접 대입하지 않고 한 단계를 더 거치는 이유

데이터 변환을 자유롭게 하기 위해
메모리를 더욱 효율적으로 관리하기 위한 고민의 결과

숫자형 데이터는 64비트(8바이트)의 공간을 확보하지만, 문자열은 특별히 정해진 규격이 없고 전체 글자 수에 따라 가변적으로 메모리 용량이 정해진다

미리 확보한 공간 내에서만 데이터 변환을 할 수 있다면
변환한 데이터를 다시 저장하기 위해 '확보된 공간을 변환된 데이터 크기에 맞게 늘리는 작업'이 선행되어야 한다
해당 공간이 메모리 상의 가장 마지막에 있다면, 뒤쪽으로 늘리기만 하면 되서 상관이 없겠지만
중간에 있는 데이터를 늘려야 하는 상황이라면, 해당 공간보다 뒤에 저장된데이터를 전부 뒤로 옮기고, 이동시킨 주소를 각 식별자에 다시 연결해야 한다
따라서 변수 영역에 값을 직접 대입하면 컴퓨터가 처리해야 할 연산이 많아지기 때문에 
효율적으로 문자열 데이터의 변환을 처리하기 위해 변수와 데이터를 별도의 공간에 나누어 저장한다

> 기존 문자열에 변화를 준다면

문자열 'abc'의 마지막에 'def'를 추가하려고 한다면
컴퓨터는 앞서 'abc'가 저장된 공간에 'abcdef'를 할당하는 대신 'abcdef' 라는 문자열을 새로 만들어 별도의 공간에 저장하고, 그 주소를 변수 공간에 연결한다
반대로 'abc'의 마지막 'c'를 제거하려고 해도 새로 만든다
기존 문자열에 어떤 변환을 가하든 상관없이 무조건 새로 만들어 별도의 공간에 저장한다
(기존 `@5004`	데이터는 자신의 주소를 저장하는 변수가 하나도 없게 되면 가비지 컬렉터 `garbage collector` 의 수거대상이 된다)

![](https://images.velog.io/images/beanlove97/post/57bb2a15-0272-40d2-a09e-606a39c0a32f/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-11-09%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2011.38.11.png)

[목차로 이동](#목차)

# 불변값과 가변값

## 불변값

변수 `variable`와 상수 `constant` 를 구분하는 성질은 '변경가능성'이다
바꿀 수 있으면 변수, 바꿀 수 없으면 상수이다.

> 불변값과 상수

변수와 상수를 구분 짓는 변경 가능성의 대상 : **변수 영역 메모리**
한 번 데이터 할당이 이뤄진 변수 공간에 다른 데이터를 재할당할 수 있는지 여부가 관건

불변성 여부를 구분할 때의 변경 가능성의 대상 : **데이터 영역 메모리**
기본형 데이터인 숫자, 문자열, boolean, null, undefined, Symbol은 모두 불변값이다

```javascript
var a = 'abc';
a = a + 'def';

var b = 5;
var c = 5;
b = 7;
```

> 변수 a에 문자열 'abc'를 할당했다가 뒤에 'def'를 추가

~~기본의 'abc'가 'abcdef'로 바뀌는 것이 아닐~~ 새로운 문자열 'abcdef'를 만들어 그 주소를 변수 a에 저장한다.
'abc', 'abcdef'는 완전히 별개의 데이터이다

>  변수 b에 숫자 5를 할당

컴퓨터는 일단 데이터 영역에서 5를 찾고, 없으면 그제서야 데이터 공간을 하나 만들어 저장해서 그 주소를 b에 저장한다

> 변수 c에 다시 같은 숫자인 5를 할당

컴퓨터는 데이터 영역에서 5를 찾고 이미 만들어놓은 값이 있기 때문에 그 주소를 재활용한다

> 변수 b의 값을 7로 변경

~~기존에 저장된 5자체를 7로 바꾸는 것이 아니라~~ 기존에 저장했던 7을 찾아서 있으면 재활용하고 없으면 새로 만들어 b에 저장한다

> 불변값의 성절

결국 5와 7 모두 다른 값으로 변경할 수 없다
문자열 값도 한 번 만든 값을 바꿀 수 없고, 숫자 값도 다른 값으로 변경할 수 없다
변경은 새로 만드는 동작을 통해서만 이루어진다
한 번 만들어진 값은 **가비지 컬렉팅**을 당하지 않는 한 영원히 변하지 않는다

## 가변값

기본형 데이터는 모두 불변형인 반면,
참조형 데이터의 기본적인 성질은 가변값인 경우가 많지만 설정에 따라 변경 불가능한 경우도 있고, 아예 불변값으로 활용하는 경우도 있다.

[목차로 이동](#목차)

# 참조형 데이터

## 참조형 데이터를 변수에 할당하는 과정

```javascript
var obj1 = {
  a: 1,
  b: 'bbb'
};
```

![](https://images.velog.io/images/beanlove97/post/735b817c-0fd4-454c-9e16-627a1294e7b7/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-11-09%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2011.50.19.png)

1. 컴퓨터는 우선 변수 영역에 빈 공간 `@1002`를 확보하고, 그 주소의 이름을 obj1로 지정한다.
2. 임의의 데이터 저장 공간 `@5001`에 데이터를 저장하려고 보니, 여러 개의 property로 이루어진 데이터 그룹이다
이 그룹 내부의 프로퍼티를 저장하기 위해 별도의 변수 영역을 마련하고, 그 영역의 주소 `@7103~?`를 `@5001`에 저장한다
객체의 프로퍼티를 저장하기 위한 메모리 영역은 ~~크기가 정해져있지 않고~~ 필요한 시점에 동적으로 확보한다
3. `@7103` 및 `@7104` 에 각각 a,b라는 프로퍼티 이름을 지정한다
4. 데이터 영역에서 숫자 1을 검색하고 검색 결과가 없으면 임의로 `@5003`에 저장하고, 이 주소를 `@7103`에 저장한다.
문자열 'bbb' 역시 임의로 `@5004`에 저장하고 이 주소를 `@7104`에 저장한다

기본형 데이터와의 차이는 '객체의 변수(프로퍼티) 영역'이 별도로 존재한다.
객체가 별도로 할애한 영역은 변수 영역일 뿐, 데이터 영역은 기존의 메모리 공간을 그대로 활용한다
데이터 영역에 저장된 값은 모두 불변값이지만, 변수에는 다른 값을 얼마든지 대입할 수 있다
이 부분 때문에 흔히 참조형 데이터는 불변하지 않다고 한다

```javascript
var obj1 = {
  a: 1,
  b: 'bbb'
};
obj1.a = 2;
```

obj1의 a 프로퍼티에 숫자 2를 할당하려고 한다
데이터 영역에서 숫자 2를 검색하는데 검색 결과가 없으므로 빈 공간인 `@5005`에 저장하고 이 주소를 `@7103`에 저장한다

변수 obj1이 바라보고 있는 주소는 `@5001`로 변하지 않는다
새로운 객체가 만들어진 것이 아니라, 기존의 객체 내부의 값만 바뀐 것이다

## 참조형 데이터인 프로퍼티에 다시 참조형 데이터를 할당하는 경우

이러한 경우를 **중첩 객체 `nested object`**

```javascript
var obj = {
  x: 3,
  arr: [ 3, 4, 5 ]
};
```

![](https://images.velog.io/images/beanlove97/post/cc7348dd-4978-400e-ba23-a23929eecddd/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-11-09%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2012.05.26.png)

1. 컴퓨터는 우선 변수 영역인 빈 공간 `@1002` 를 활보하고, 그 주소의 이름을 obj로 지정한다
2. 임의의 데이터 저장공간 `@5001` 에 데이터를 저장하려는데, 이 데이터는 여러 개의 변수와 값들을 모아놓은 그룹 (객체)이다.
이 그룹의 각 변수(프로퍼티)들을 저장하기 위해 별도의 변수 영역을 마련하고 `@7103~?`, 그 영역의 주소를 `@5001`에 저장한다
3. `@7103`에 이름 x를, `@7104` 에 이름 arr를 지정한다
4. 데이터 영역에서 숫자 3을 검색했는데 없기 때문에 임의로 `@5002`에 저장하고, 이 주소를 `@7103`에 저장한다
5. `@7104`에 저장할 값은 배열로서 역시 데이터 그룹이다.
이 그룹 내부의 프로퍼티를 저장하기 위해 별도의 변수 영역을 마련하고 `@8104~?`, 그 영역의 주소 정보 `@8104~?` 를 `@5003`에 저장한 다음, `@5003` 을 `@7104` 에 저장한다
6. 배열의 요소가 총 3개이기 때문에 3개의 변수 공간을 확보하고, 각각 인덱스를 부여한다 (0,1,2)
7. 데이터 영역에서 숫자 3을 검색해서 `@5002` 그 주소를 `@8104`에 저장한다
8. 데이터 영역에 숫자 4가 없기 때문에 `@5004`에 저장하고, 이 주소를 `@8105`에 저장한다
8. 데이터 영역에 숫자 5가 없기 때문에 `@5005`에 저장하고, 이 주소를 `@8106`에 저장한다.


## 참조형 데이터의 프로퍼티 검색

> `obj.arr[1]` 검색한다면

1. obj 검색 1: obj이라는 식별자를 가진 주소를 찾는다 `@1002`
2. obj 검색 2: 값이 주소이기 때문에 그 주소로 이동한다 `@5001`
3. obj 검색 3: 값이 주소이기 때문에 그 주소로 이동한다 `@7103~?`

4. obj.arr 검색 1: arr라는 식별자를 가진 주소를 찾는다 `@7104`
5. obj.arr 검색 2: 값이 주소이기 때문에 그 주소로 이동한다 `@5003`
6. obj.arr 검색 3: 값이 주소이기 때문에 그 주소로 이동한다 `@8104~?`

7. `obj.arr[1]` 검색 1: 인덱스 1에 해당하는 주소를 찾는다 `@8105`
8. `obj.arr[1]` 검색 2: 값이 주소이기 때문에 그 주소로 이동 `@5004`
9. `obj.arr[1]` 검색 3: 값이 숫자형 데이터이기 때문에 4반환

```
@1002 -> @5001 -> (@7103~?) -> @7104 -> @5003 -> (@8104~?) -> @5004 -> 4반환
```

## 참조 카운트

```javascript
obj.arr = 'str';
```

만약 이 상태에서 재할당 명령을 내린다면
`@5006`에 문자열 'str'을 저장하고, 그 주소를 `@7104`에 저장한다
그러면 `@5003`은 더이상 자신의 주소를 참조하는 변수가 하나도 없게 된다

**참조 카운트** : 어떤 데이터에 대해 자신의 주소를 참조하는 변수의 개수

`@5003`의 참조 카운트는 `@7104`에 `@5003`이 저장되어 있던 시점까지는 1이었다가
`@7104`에 `@5006` 이 저장되는 순간 0이 되고
참조 카운트가 0인 메모리 주소는 **가비지 컬렉터**의 수거대상이 된다

> 가비지 컬렉터 (GC: garbage collector)

런타임 환경에 따라 특정 시점이나 메모리 사용량이 포화 상태에 임박할 때마다 자동으로 수거 대상들을 수거한다.
수거된메모리는 다시 새로운 값을 할당할 수 있는 빈 공간이 된다

![](https://images.velog.io/images/beanlove97/post/277cf351-f5f6-4c34-b44d-53376d1be424/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-11-09%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2012.16.49.png)

`@5003`은 참조 카운트가 0이 됨에 따라 GC 대상이 되고, 이후 언젠가 담겨 있던 데이터인 `@8104~?` 라는 값은 사라진다
이 과정에서 연쇄적으로 `@8104~?` 의 각 데이터들의 참조 카운트가 0이 되고, 이들 역시 GC의 대상이 되어 함께 사라질 것이다.

[목차로 이동](#목차)

# 기본형 데이터와 참조형 데이터 비교

> 변수 복사 비교

```javascript
var a = 10;
var b = a;

var obj1 = { c: 10, d: 'ddd' };
var obj2 = obj1;
```

![](https://images.velog.io/images/beanlove97/post/ec4b6e51-0589-4bdf-b1ec-f36aeed147b7/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-11-09%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2012.18.12.png)

### 기본형 데이터

**변수선언** : 변수 영역의 빈 공간 `@1001`을 확보하고 식별자 a로 지정한다
**데이터 할당**
- 숫자 10을 데이터 영역에서 검색하고 없으므로 빈 공간 `@5001`에 저장한 다음, 이 주소를 `@1001`에 넣는다
- 변수 영역의 빈 공간 `@1002`를 확보하고 식별자를 b로 지정한다
**복사**: 식별자 a를 검색해 그 값을 찾아와야 하는데, `@1001`에 저장된 값인 `@5001`을 들고 좀 전에 확보한 `@1002` 에 값으로 대입한다

### 참조형 데이터

**변수선언** : 변수 영역의 빈공간 `@1003` 을 확보해 식별자 obj1로 지정한다
**데이터할당** 
- 데이터 영역인 빈 공간 `@5002` 를 확보하고, 데이터 그룹에 담겨야하기 때문에 별도의 변수영역 @7103~을 확보해 그 주소를 저장한다
- @7103에는 식별자 c를, @7104에는 식별자 d를 입력한 다음, c에 대입할 값 10을 데이터 영역에서 검색한다
- @5001에 이미 저장되어있기 때문에 이 주소를 @7103에 연결하고, 문자열 'ddd'는 데이터 영역의 빈 공간에 새로 만들어서 @7104에 연결한다
**복사**
- 변수 영역의 빈 공간 @1004를 확보하고 식별자를 obj2를 지정한다
- 식별자 onj1를 검색해 (@1003) 그 값인 @5002를 들고, @1004에 대입한다

### 변수를 복사하는 과정

기본형 데이터와 참조형 데이터 모두 같은 주소를 바라보게 되는 점에서 동일하다
@1001과 @1002는 모두 값이 @5001이 됐고, @1003과 @1004에는 모두 값이 @5002가 됐다.
복사 과정은 동일하지만, 데이터 할당 과정에서 이미 차이가 있기 때문에 변수 복사 이후의 동작에도 큰 차이가 발생한다

```javascript
var a = 10;
var b = a;
var obj1 = { c:10, d:'ddd' };
var obj2 = obj1;

// 이번에 볼 내용
b = 15;
obj2.c = 20;
```

![](https://images.velog.io/images/beanlove97/post/cf66f0a8-7b07-4da1-926e-71c4ae790a16/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-11-09%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2012.29.10.png)

데이터 영역에 아직 15가 없기 때문에 새로운 공간 @5004에 저장하고,
그 주소를 든 채로 변수 영역에서 obj2를 찾고 (@1004),
obj2의 값인 @5002가 가리키는 변수 영역에서 다시 c를 찾아 (@7103) 그 곳에 @5005를 대입한다

### 기본형과 참조형 데이터의 가장 큰 차이점

기본형 데이터를 복사한 변수 b의 값을 바꿨더니, @1002의 값이 달라진 반면,
참조형 데이터를 복사한 변수 obj2의 프로퍼티의 값을 바꾸었더니 @1004의 값은 달라지지 않았다
변수 a와 b는 서로 다른 주소를 바라보게 되었으나, 변수 obj1와 obj2는 여전히 동일한 객체를 바라보고 있는 객체이다

```javascript
a ~== b
obj1 === obj2
```

대부분의 자바스크립트 책에서 *기본형은 값으 복사하고 참조형은 주솟값을 복사한다* 고 설명하지만,
사실은 **어떤 데이터 타입이던 변수에 할당하기 위해서는 주솟값을 복사해야 하기 때문에, 엄밀히 따지면 자바스크립트의 모든 데이터 타입은 참조형 데이터일 수밖에 없다**
다만 기본형은 주솟값을 복사하는 과정이 한 번만 이뤄지고, 참조형은 한 단계를 더 거치게 된다는 차이가 있다.

> 객체 자체를 변경했을 때

```javascript
var a = 10;
var b = a;
var obj1 = {c: 10, d: 'ddd' };
vat obj2 = obj1;

b = 15;
obj2 = {c: 20, d: 'ddd'};
```

![](https://images.velog.io/images/beanlove97/post/1b17a42f-9496-4f23-9762-924ce9e8f876/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-11-09%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2012.37.01.png)

변수의 값 (b)을 직접 변경할 때와 값이 아닌 내부 프로퍼티 (obj2.c)를 변경할 때의 결과를 비교하자면, 애초에 비교대상의 조건 자체가 서로 다르기 때문에 동작도 다른 것이 당연하다
같은 조건인 상태에서 비교하면 b의 경우와 마찬가지로

- obj2에도 새로운 객체를 할당함으로써 값을 직접 변경하고
- 메모리의 데이터 영역의 새로운 공간에 새 객체가 저장되고
- 그 주소를 변수 영역의 obj2 위치에 저장한다

따라서 객체에 대한 변경에도 값이 달라졌다.
참조형 데이터가 '가변값'이라고 설명할 때의 '가변' : 참조형 데이터 자체를 변경할 경우가 아니라 그 내부의 프로퍼티를 변경할 때만 성립한다

[목차로 이동](#목차)

# 불변 객체

## 불변 객체 (immutable object)

최근의 React, Vue.js, Angular 등의 라이브러리나 프레임워크에서뿐만 아니라 함수형 프로그래밍, 디자인 패턴 등에서도 매우 중요한 기초가 되는 개념이다
참조형 데이터의 **가변** : 데이터 자체가 아닌 내부 프로퍼티를 변경할 때만 성립한다
데이터 자체를 변경하려고 하면 (=새로운 데이터를 할당하고자 하면) 기본형 데이터와 마찬가지로 기존 데 이터는 변하지 않는다

내부 프로퍼티를 변경할 필요가 있을 때마다 매번 새로운 객체를 만들어 재할당하기로 규칙을 정하거나
자동으로 새로운 객체를 만드는 도구 *대표적으로 immutable.js, immuer.js, immutability-helper 등의 라이브러리가 있고, ES6의 spread operator, Object.assign 메서드 등도 같은 목적으로 활용이 된다* 를 활용한다면 객체 역시 불변성을 확보할 수 있다
혹은 불변성을 확보할 필요가 있을 경우에는 불변객체로 취급하고, 그렇지 않은 경우에는 기존 방식대로 사용하는 식으로 상황에 따라 대처해도 된다

### 불변 객체가 필요한 경우

값으로 전달받은 객체에 변경을 가하더라도 원본 객체는 변하지 않아야 하는 경우가 종종 발생한다

### 객체의 가변성으로 인한 문제점

```javascript
var user = {
  name: 'Eunjeong',
  gender: 'female'
};

var changeName = function (user, newName) {
  var newUser = user;
  newUser.name = newName;
  return newName;
};

var user2 = changeName(user,'Jung');

if (user !== user2 ) console.log('유저 정보가 변경되었습니다.');

console.log(user.name, user2.name); // Jung Jung
console.log(user === user2) // true
```

처음에 user 객체를 생성하고 다시 user 객체의 name 프로퍼티를 'Jung'으로 바꾸는 함수 changeName을 호출해서 그 결과를 user2 변수에 담았다.

user 변수와 user2 변수가 서로 같지 않다는 조건이 성립하면 '유저 정보가 변경되었습니다.' 라는 내용이 출력되겠지만, 실제로는 출력없이 통과한다
두 변수의 name, 프로퍼티 모두 'Jung'으로 출력되고, 두 변수가 서로 동일하다고 한다

### 불변 객체를 만드는 간단한 방법 

> 객체의 가변에 따른 문제점의 해결방법

만약 if 조건문처럼 정보가 바뀐 시점에서 알림을 보내야 한다거나, 바뀌기 전의 정보와 바뀐 후의 정보의 차이를 가시적으로 보여줘야 하는 등의 기능을 구현하기 위해서는 변경 전과 후에 서로 다른 객체를 바라보게 만들면 된다

```javascript
var user = {
  name: 'Eunjeong',
  gender: 'female'
};

var changeName = funtion (user, newName) {
  return {
    name: newName,
    gender: user.gender
  };
};

var user2 = changeName(user, 'Jung');

if (user !== user2) console.log('유저 정보가 변경되었습니다.'); // 유저 정보가 변경되었습니다.

console.log(user.name, user2.name); // Jung Jung
console.log(user === user2) // false
```

changeName 함수가 새로운 객체를 반환하도록 설정했다
이제 user와 user2는 서로 다른 객체이기 때문에 안전하게 변경 전과 후를 비교할 수 있다
다만 changeName 함수는 새로운 객체를 만들면서 변경할 필요가 없는 기존 객체의 프로퍼티 (gender)를 하드코딩으로 입력했다.
이런 식으로는 대상 객체에 정보가 많을수록, 변경해야 할 정보가 많을수록 사용자가 입력하는 수고가 늘어날 것이다.
이런 방식보다는 대상 객체의 프로퍼티 개수에 상관없이 모든 프로퍼티를 복사하는 함수를 만들면 좋을 것 같다

### 기존 정보를 복사해서 새로운 객체를 반환하는 함수 ver.얕은복사

```javascript
var copyObject = function (target) {
  var result = {};
  for (var prop in target) result[prop] = target[prop];
  return result;
};
```

copyObject는 for in 문법을 이용해 result 객체에 target 객체의 프로퍼티를 복사한다

*프로토타입 체이닝 상의 모든 프로퍼티를 복사하는 점, getter/setter는 복사하는 점, 얕은 복사만을 수행한다는 점에서 아쉽기 하지만 이 문제를 모두 보완하려면 함수가 무거워지고, 일단 user 객체에 대해서는 문제가 되지 않기 때문에 일단 진행한다
이 내용은 이후 얕은 복사, 깊은 복사를 다루며 해결하려고 한다*

```javascript
var user = {
  name: 'Eunjeong',
  gender: 'female'
};

var user2 = copyObject(user);
user2.name = 'Jung';

if (user !== user2) console.log('유저 정보가 변경되었습니다.'); // 유저 정보가 변경되었습니다.

console.log(user.name, user2.name); // eunJeong Jung
console.log(user === user2); // false
```

copyObject 함수를 통해 간단하게 객체를 복사하고 내용을 수정하는 데 성공했기 때문에
앞으로는 협업하는 모든 개발자들이 user 객체 내부의 변경이 필요할 때는 무조건 copyObject 함수를 사용하기로 합의하고 그 규칙을 지킨다는 전제하에서는 user 객체가 곧 불변객체라고 볼 수 있다

모두가 그 규칙을 따르지 않고는 프로퍼티를 변경할 수 없게끔 시스템적으로 제약을 거는 편이 안전하기 때문에
~~자바스크립트 내장 객체가 아닌~~ 라이브러리 자체에 불변성을 지닌 별도의 데이터 타입과 그에 따른 메서드를 제공하는 **immutable.js baobab.js** 등의 라이브러리가 등장하고 많이 사용된다

[목차로 이동](#목차)

# 얕은 복사와 깊은 복사

얕은 복사 `shallow copy` : 바로 아래 단계의 값만 복사하는 방식
깊은 복사 `deep copy` : 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방식

> 얕은 복사

중첩된 객체에서 참조형 데이터가 저장된 프로퍼티를 복사할때 그 주솟값만 복사한다
해당 프로퍼티에 대해 원본과 사본 모두 동일한 참조형 데이터의 주소를 가리키게 된다
사본을 바꾸면 원본도 바뀌고, 원본을 바꾸면 사본도 바뀐다

```javascript
var user = {
  name: 'Eunjeong',
  urls: {
    portfolio: 'http://github.com/abc',
    blog: 'https://velog.io/@beanlove97'
    facebook: 'http://facebook.com/abc'
  }
};
var user2 = copyObject(user);

user2.name = 'Jung';
console.log(user.name === user2.name); // false

user.urls.portfolio = 'http://portfolio.com';
console.log(user.urls.portfolio === user2.urls.portfolio); //true

user2.url.blog = '';
console.log(user.urls.blog === user2.urls.blog) // true
```

사본인 user2와 name 프로퍼티를 바꿔도 user의 name 프로퍼티는 바뀌지 않는다
만약 원본과 사본 중 어느 쪽을 바꾸더라도 다른 한쪽의 값도 함께 바뀐 것을 확인할 수 있다
즉, user 객체에 직접 속한 프로퍼티에 대해서는 복사해서 완전히 새로운 데이터가 만들어진 반면,
한 단계 더 들어간 urls의 내부 프로피트들은 **기존 데이터를 그대로 참조한다**

> 깊은 복사를 통한 user.urls 프로퍼티를 불변 객체로 만들기

```javascript
var user2 = copyObject(user);
user2.urls = copyObject(user.urls);

user.urls.portfolio = 'http://portfolid.com';
console.log(user.urls.portfolio === user2.urls.portfolio); // false

user.urls.blog = '';
console.log(user.urls.blog === user2.urls.blog) // false
```

urls 프로퍼티에 copyObject 함수를 실행한 결과를 할당햇다
urls 프로퍼티의 내부까지 복사해서 새로운 데이터가 만들어졌기 때문에 기존의 객체와 값이 서로 다르다는 결과를 얻을 수 있다

어떤 객체를 복사할때 객체 내부의 모든 값을 복사해서 완전히 새로운 데이터를 만들고자 할 때,
객체의 프로퍼티 중에서 그 값이 **기본형 데이터**일 경우에는 그대로 복사하면 되지만,
**참조형 데이터**는 다시 그 내부의 프로퍼티를 복사해야 한다

이 과정을 참조형 데이터가 있을 때마다 재귀적으로 수행해야 비로소 깊은 복사가 되는 것이다

> 객체의 깊은 복사를 수행하는 범용 함수

```javascript
var copyObjectDeep = function(target) {
  var result = {};
  if (typeof target === 'object' && target !== null) {
    for (var prop in target) result[prop] = copyObjectDeep(target[prop]);
  } else result = target;
  return result;
};
```

target이 객체인 경우에는 내부 프로퍼티를 순회하며 copyObjectDeep 함수를 재귀적으로 호출하고,
객체가 아닌 경우에는 target을 그래도 지정하게끔 했다
target !== null 조건을 덧붙인 이유 : typeof 명령어가 null에 대해서도 'object' 반환하기 때문이다 (자바스크립트 자체의 버그)

이 함수를 사용해 객체를 복사한 다음에는 원본과 사본이 서로 완전히 다른 객체를 참조하게 되어 어느 쪽의 프로퍼티를 변경하더라도 다른 쪽에 영향을 주지 않는다

```javascript
var obj = {
 a: 1,
 b: {
   c: null,
   d: [1, 2]
 }
};

var obj2 = copyObjectDeep(obj);

obj2.a = 3;
obj2.b.c = 4;
obj.b.d[1] = 3;

console.log(obj); // { a: 1, b: {c: null, d: [1,3] } }
console.log(obj2); // [a: 3, b: {c:4, d: {0:1, 1:2} } }
```

추가로 hasOwnProperty 메서드를 활용해서 프로토타입 체이닝을 통해 상속된 프로퍼티를 복사하지 않게끔 할 수도 있다
ES5의 getter/setter를 복사하는 방법은 아래 두가지 방법을 통해서만 가능하다

- ES6의 Object.getOwnPropertyDescriptor
- ES2017의 Object.gerOwnPropertyDescriptor

> 간단하게 깊은 복사 처리하는 방법

객체를 JSON 문법으로 표현된 문자열로 전환했다가 다시 JSON 객체로 바꾼다
다만 메서드(함수)나 숨겨진 프로퍼티인 `__proto__` 나 getter/setter 등과 같이 JSON으로 변경할 수 없는 프로퍼티는 모두 무시한다
httpRequest로 받은 데이터를 저장한 객체를 복사할 때 등 순수한 정보만 다룰 때 활용하기 좋은 방법이다

```javascript
var copyObjectVisJSON = function (target) {
  return JSON.parse(JSON.stringfy(target));
};

var obj = {
  a: 1,
  b: {
    c: null,
    d: [1,2],
    func1: function () console.log(3)
  },
  func2: function () console.log(4)
};

obj2.a = 3;
obj2.b.c = 4;
obj.b.d[1] = 3;

console.log(obj);  // { a: 1, b: {c: null, d: [1,3], func1: f() }, func2: f() }
console.log(obj2); // { a: 3, b: { c:4, d:[1,2] } }
```

[목차로 이동](#목차)

# undefined와 null

> 자바스크립트에서 말하는 '없음'을 나타내는 값

undefined, null

## undefined

사용자가 명시적으로 지정할 수도 있지만 값이 존재하지 않을 때 자바스크립트 엔진이 자동으로 부여되는 경우도 있다

자바스크립트 엔진은 사용자가 응당 어떤 값을 지정할 것이라고 예상되는 상황임에도
실제로는 그렇게 하지 않았을 때 undefined를 반환한다.

- 값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때
- 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때
- return 문이 없거나 호출되지 않는 함수의 실행 결과

```javascript
var a; // var 변수는 LE가 활성화될 때 생성되면서 동시에 undefined로 초기화된다 
console.log(a); // undefined: 값을 대입하지 않은 변수에 접근

var obj = [ a: 1 };
console.log(obj.a); // 1
console.log(obj.b); // undefined: 존재하지 않는 프로퍼티에 접근
console.log(b); // c. f)ReferenceError: b is not defined

var func = function() { };
var c = func(); // return값이 없으면 undefined를 반환한 것으로 간주
console.log(c); // undefined
```

값을 대입하지 않은 경우에 대해 배열의 경우, 조금 특이한 동작을 확인할 수 있다

```javascript
var arr1 = [];
arr1.length = 3;
console.log(arr1); // [empty x 3]
```

arr1에 빈 배열을 할당하고, 배열의 크기를 3으로 만들자, `[empty x 3]`을 출력했다.
empty: 배열에 3개의 빈 요소를 확보했지만 확보된 각 요소에는 문자 그대로 어떤 값도, 심지어 undefined조차도 할당돼 있지 않다

```javascript
var arr2 = new Array(3);
console.log(arr2); // [empty x 3]
```

new 연산자와 함께 Array 생성자 함수를 호출함으로써 배열 인스턴스를 생성했는데,
이때 배열의 크기는 3으로 지정했다.


```javascript
var arr3 = [undefined, undefined, undefined]
console.log(arr3); // [undefined, undefined, undefined]
```

리터럴 방식으로 배열을 생성하면서 각 요소에 undefined를 부여했다

따라서 **비어있는 요소**와 **undefined를 할당한 요소**는 출력 결과부터 다르다

> 비어있는 요소 : 순회와 관련된 많은 배열 메서드들의 순회 대상에서 제외된다

```javascript
var arr1 = [undefined, 1];
var arr2 = [];
arr2[1] = 1;

arr1.forEach(function(v, i) { console.log(v, i); }); // undefined 0 / 1 1
arr2.forEach(function(v, i) { console.log(v, i); }); // 1 1

arr1.map(function(v, i) { return v + i; }); // [NaN, 2]
arr2.map(function(v, i) { return v + i; }); // [empty, 2]

arr1.filter(function(v) { return |v|; }); // [undefined]
arr2.filter(function(v) { return |v|; }); // []

arr1.reduce(function(p, c, i) { return p + c+ i; }, ''); // undefined011
arr2.reduce(function(p, c, i) { return p + c+ i; }, ''); // 11
```

arr1은 undefined와 1을 직접 할당했지만, arr2은 빈 배열의 인덱스 1에 값 1을 할당했다
이 두 배열은 배열의 각 요소를 순회하는 것을 기본으로 추가적인 기능을 수행하는 메서드에서 서로 다른 결과를 보인다

사용자가 직접 undefined를 할당한 arr1에 대해서는 일반벅으로 알고 있는 대로 배열의 모든 요소를 순회해서 결과를 출력한다
arr2에 대한 결과를 보면, 각 메서드들이 비어있는 요소에 대해서는 어떠한 처리를 하지 않고 건너뛴다

배열도 객체라는 것을 생각해보면, 존재하지 않는 프로퍼티에 대해서는 순회할 수 없다는 결론이 나온다
~~배열은 무조건 length 프로퍼티의 개수만큼 빈 공간을 확보하고 각 공간에 인덱스를 이름으로 지정한 것이라고 생각하기 쉽지만,~~

실제로는 객체와 마찬가지로
- 특정 인덱스에 값을 지정할 때 비로소 빈 공간을 확보하고
- 인덱스를 지정하고 데이터의 주솟값을 저장하는 등의 동작을 한다

값이 지정되지 않은 인덱스는 '아직은 존재하지 않는 프로퍼티'에 지나지 않는다

> 사용자가 명시적으로 부여한 경우의 undefined

그 자체로 값
비록 '비어있음'을 의미하지만 하나의 값으로 동작하기 때문에
이때의 프로퍼티나 배열의 요소는 고유의 키값(프로퍼티 이름)이 실존하게 되고,
따라서 순회의 대상이 될 수 있다

> 비어있는 요소에 접근하려 할 때 반환 되는 경우의 undefined

자바스크립트 엔진이 하는 수 없이 반환해주는 undefined
해당 프로퍼티 내지 배열의 키 값(인덱스) 자체가 존재하지 않음을 의미한다
값으로써 어딘가에 할당된 undefined는 실존하는 데이터인 반면,
자바스크립트 엔진이 반환해주는 undefined는 문자 그대로 값이 없음을 나타낸다

> var, let & const

var 변수는 LE가 활성화될 때 생성되면서 동시에 undefined로 초기화된다 
ES6에서 등장한 let, const에 대해서는 undefined를 할당하지 않은 채로 초기화를 마치며,
이후 특정 값을 할당하기 전까지는 해당 변수에 접근할 수 없다
let와 const 변수는 LE가 활성화될 때 생성되지만 실제 변수가 평가되기 전까지는 접근할 수 없다

## null

자바스크립트 엔진이 반환하는 경우는 우리의 통제 범위를 벗어나므로 
직접 undefined를 할당하지 않아, 모든 undefined가 오직 이 경우에만 해당하게끔 해주면 된다

같은 의미를 가진 null이라는 값이 별도로 있는데 굳이 undefined를 써야하는 이유는 없기 때문에
**비어있음**을 명시적으로 나타내고 싶을 때에는 ~~undefined가 아닌~~ null을 쓰면 된다
이런 규칙을 따른다면, undefined는 오직 *값을 대입하지 않은 변수에 접근하고자 할 때 자바스크립트 엔진이 반환해주는 값*으로서만 존재할 수 있다

### null의 주의점

자바스크립트 자체 버그로 인한, `typeof null === object`
따라서 어떤 변수의 값이 null인지 여부를 판별하기 위해서는 typeof 대신 다른 방식으로 접근해야 한다

```javascript
var n = null;
console.log(typeof n); // object

console.log(n == undefined); //true
console.log(n == null); // true

console.log(n === undefined); // false
console.log(n === null); // true
```

동등 연산자 `==` 로 비교할 경우, null와 undefined가 서로 같다고 판단한다
따라서 일치 연산자 `===` 를 써야만 정확하게 판별할 수 있다

[목차로 이동](#목차)

# 정리

1. 자바스크립트 데이터 타입

기본형 : 불변값
참조형 : 가변값

2. 변수와 식별자

변수 : 변경 가능한 데이터가 담길 수 있는 공간
식별자 : 그 변수의 이름

3. 변수 선언

- 컴퓨터는 우선 빈 공간에 식별자를 저장하고
- 그 공간에 자동으로 undefined를 할당한다
- 그 변수에 기본형 데이터를 할당하려고 하면
	- 별도의 공간에 데이터를 저장하고
    - 그 공간의 주소를 변수의 값 영역에 할당한다

4. 참조형 데이터 할당

- 컴퓨터는 참조형 데이터 내부 프로퍼티들을 위한 변수 영역을 별도로 확보해서 확보된 주소를 변수에 연결하고
- 각 데이터를 별도의 공간에 저장해서 그 주소를 식별자들과 매칭시킨다

> 데이터 할당에서 기본형과 차이나는 이유

참조형 데이터가 여러 개의 프로퍼티(변수)를 모은 **그룹**이기 때문이다
그리고 이러한 차이로 인해 참조형 데이터를 *가변값*으로 여겨야만 하는 상황이 발생한다

참조형 데이터를 가변값으로 여겨야 하는 상황임에도 이를 불변값으로 사용하는 방법
: 내부 프로퍼티들을 일일이 복사 (깊은복사)하거나, 라이브러리 사용

5. 없음을 나타내는 값

> undefined

어떤 변수에 값이 존재하지 않을 경우

> null

사용자가 명시적으로 '없음'을 표현하기 위해 대입한 값

본래의 의미에 따라 사용자가 없음을 표현하기 위해 명시적으로 undefined를 대입하는 것은 지양하는 것이 좋다

[목차로 이동](#목차)

