# 동기 vs 비동기

> 싱글 스레드 vs 멀티 스레드

이 이야기는 나중에 다루게 되겠지만, 간단하게 다뤄보기로 한다.
싱글 스레드 : 한 번에 task 하나만 실행할 수 있다.
멀티 스레드 : 한 번에 여러 task를 동시에 실행할 수 있다.

## 동기 (Synchronouse)

현재 실행 중인 코드가 끝나야 다른 코드가 실행되는 것을 말한다. 
즉, 현재 실행 중인 task가 종료될 때까지, 다음 task가 대기하는 것이다.

```javascript
const arr = [];

for (let i = 0; i < 100; i++) {
  arr.push(i);
}

console.log(arr);

for (let i = 100; i < 200; i++) {
  arr.push(i);
}

console.log(arr);
```

> 장점 및 단점

동기적인 특성은 코드를 위에서부터 순서대로 하나씩 실행하기 때문에 실행 순서가 보장되는 점에서는 장점일 수 있으나, 
현재 실행 중인 task가 종료될 때까지 다음 task가 실행되지 않는 점이 단점이다.

이렇게 task가 실행되지 않는 것을 **블로킹 `blocking`** 이라고 한다.

```javascript
const arr = [];

for (let i = 0; i < 5000; i++) {
  // 5000번 반복하면서 실행할 복잡한 코드
}

console.log(arr);

for (let i = 4000; i < 100000; i++) {
  // 6000번 반복하면서 실행할 수학 계산식
}

alert('Hello');
console.log(arr);
```

for 반목문의 내용이 너무 복잡하기 때문에 매번 반복할 때마다 복잡한 계산을 해야하는 경우, Javascript가 아무리 빨라도 반복할 횟수도 많아 느릴 수 있다.

> #### alert()

뿐만 아니라, alert() 함수는 사용자가 확인버튼을 누르기 전까지 실행이 안되기 때문에 아래에 있는 console도 같이 blocking된다

### 비동기처리가 필요한 이유

front에서 blocking이 되면 화면을 보여줄 수 없기 때문에 자바스크립트에서 비동기처리가 필요하게 되었다.

## 비동기 (Synchronouse)

현재 실행 중인 코드가 완료되지 않아도, 다음 코드가 실행되는 것을 말한다.
원래 자바스크립트의 특성대로라면 원래는 응답하고 기다려야 하겠지만, 비동기 task는 브라우저에게 맡겨놓고 다음 task 먼저 실행하는 것이다.

> #### axios(), fetch()

비동기 함수의 대표적인 예시로는 `axios()` 함수가 있다.
axios, fetch 함수로 API 함수를 호출시켰지만 언제 응답이 올 지 모르기 때문에 일단 브라우저에게 맡겨 놓고 다른 로직을 먼저 실행한다.

```javascript
axios.get(url)
.then(response => {
  // api 호출하고 응답받으면 실행
})

// 화면렌더링
// 다른 로직2
```

> 장점

위와 같은 통신함수인 경우, 와이파이가 엄청 느리거나 응답할 데이터가 너무 많으면 사용자는 빈 페이지에서 한참을 기다려야겠지만, 이러한 비동기적인 특성덕분에 해당 응답이 불러와지지 않아도 일단 다른 부분은 먼저 렌더링이 된다

즉, 현재 실행 중인 task가 완료되지 않아도 다음 task를 실행하기 때문에 blocking이 발생하지 않는다

> 단점

동일한 관점에서도 단점이 생길 수 있는데,
예를 들어 우리집의 와이파이 속도와 도서관의 와이파이 속도가 달라서 실행 순서가 달라질 수 있다.

| 실행순서 | 우리 집 | 도서관 |
|-|-|-|
|-| A → B → axios 응답 → C | A → B → C → axios 응답 |

즉, task의 실행 순서가 보장되지 않는다.



