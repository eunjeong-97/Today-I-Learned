# 클로저 (Closure)

## 클로저란?

- 컴퓨터 언어에서 클로저는 **일급 객체 함수 `first class function`** 의 개념을 이용하여 스코프에 묶인 변수를 바인딩하기 위한 일종의 기술

- 함수를 일급 객체로 취급하는 여러 함수형 프로그래밍 언어에서 사용되는 보편적인 특성 (Javascript도 포함됨)

> #### 일급 객체 함수
값으로 쓰일 수 있다 : 못쓰이는 경우도 있기 때문에 특별한 경우이다
인자로 넘길 수 있다

## 클로저의 특징

- `함수를 선언할 때` 만들어진 scope가 사라진 후에도 호출할 수 있는 함수
- **`scope가 끝난 외부 함수의 변수를 참조할 수 있다`** : 스코프가 끝나서 더 이상 변수에 접근할 수 없는 상황임에도 불구하고, 사용할 수 있는 것
- 예시 : 어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우, A의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상

```javascript
var A = function() {
	var a = 1;

	var B = function() {
		return ++a;
	};

	return B;
};

var outer = A(); // 여기서 스코프 종료
console.log(outer());  // 2
console.log(outer());  // 3
```

> 코드 설명

1. var outer = A() 에서 함수 B자체를 반환함
  - A() 를 실행했기 때문에 A의 실행컨텍스트는 종료됨
  - outer 변수는 이제 B함수를 참조하게 됨 (바라보게 됨)

2. outer() : outer를 호출하면, (=B를 호출하게 되면) a의 값은 계속 증가함
  - B함수에는 a의 유효범위가 아니기 때문에, 바깥 A의 스코프를 참조하고 계속 값이 증가함 `scope chain`
  - 즉, A의 스코프가 종료된 이후에도 a변수가 쓰이게 된다

## 메모리 관리

- Javascript는 원래 메모리 관리에 신경쓰지 않아도 된다
- 사용하지 않는 변수는 자동으로 Garbage Collector (GC)에 수집된다 
- 그런데 closure는 의도적으로 변수를 사용하기 때문에 메모리가 계속 소모된다
- 만약 변수 a에 null이나 undefined를 할당하면 GC에 수집된다

- 변수를 선언할 때마다 메모리를 소모하기 때문에 자바스크립트에서는 `알아서` Garbage Collector(GC)에 넣어주게 된다
- 따라서 변수 a도 원래는 GC에 들어가야되는데 여기서는 계속 사용하게 되므로, 메모리에 남아있게 된다
- 이런 현상이 많아지면 메모리 누수가 발생할 수 있다
